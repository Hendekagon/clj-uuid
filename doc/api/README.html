<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>## The Most Recent Release</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">clj-uuid</span> <span class="project-version">0.2.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="README.html"><div class="inner"><span>## The Most Recent Release</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><a href="clj-uuid.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clj-uuid</span></div></a></li><li class="depth-2 branch"><a href="clj-uuid.bitmop.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bitmop</span></div></a></li><li class="depth-2 branch"><a href="clj-uuid.clock.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clock</span></div></a></li><li class="depth-2 branch"><a href="clj-uuid.constants.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>constants</span></div></a></li><li class="depth-2 branch"><a href="clj-uuid.node.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>node</span></div></a></li><li class="depth-2 branch"><a href="clj-uuid.random.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>random</span></div></a></li><li class="depth-2"><a href="clj-uuid.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#clj-uuid" id="clj-uuid"></a>clj-uuid</h1>
<blockquote>
<p><em>"The intent of the UUID is to enable distributed systems to uniquely</em> <em>identify information without significant central coordination."</em> – <a href="http://en.wikipedia.org/wiki/Universally_unique_identifier"><em>Wikipedia/UUID</em></a></p>
</blockquote>
<hr />
<p><a href="https://travis-ci.org/danlentz/clj-uuid"><img src="https://travis-ci.org/danlentz/clj-uuid.svg?branch=master" alt="Build Status" /></a></p>
<p><strong>clj-uuid</strong> is a Clojure library for generation and utilization of UUIDs (Universally Unique Identifiers) as described by <a href="http://www.ietf.org/rfc/rfc9562.txt"><strong>IETF RFC-9562</strong></a>.</p>
<p>This library extends the standard Java UUID class to provide true v1 (time based) and v3/v5 (namespace based) identifier generation. Additionally, a number of useful supporting utilities are provided to support serialization and manipulation of these UUIDs in a simple, efficient manner.</p>
<p>The essential nature of the value RFC9562 UUIDs provide is that of an enormous namespace and a deterministic mathematical model by means of which one navigates it. UUIDs represent an extremely powerful and versatile computation technique that is often overlooked, and underutilized. In my opinion, this, in part, is due to the generally poor quality, performance, and capability of available libraries and, in part, due to a general misunderstanding in the popular consiousness of their proper use and benefit. It is my hope that this library will serve to expand awareness, make available, and simplify use of RFC9562 identifiers to a wider audience.</p>
<h3><a href="#the-most-recent-release" id="the-most-recent-release"></a>The Most Recent Release</h3>
<p>With Leiningen:</p>
<p><a href="http://clojars.org/danlentz/clj-uuid"><img src="http://clojars.org/danlentz/clj-uuid/latest-version.svg" alt="Clojars Project" /></a></p>
<h3><a href="#how-is-it-better" id="how-is-it-better"></a>How is it better?</h3>
<p>The JVM version only provides an automatic generator for random (v4) and (non-namespaced) pseudo-v3 UUID’s.  Where appropriate, this library does use the internal JVM UUID implementation.  The benefit with this library is that clj-uuid provides an easy way to get fast time-based (v1, v6), true namespaced (v3, v5), and high quality cryptographcically secure time-based (v7) UUIDs.</p>
<h3><a href="#but-wait-why-so-many-choices" id="but-wait-why-so-many-choices"></a>But wait, why so many choices?</h3>
<p>Each version of UUID offers advantages in particular situations. Please read on to learn more, but, to help put you at ease, your decision on which is appropriate to use will usually be clear.</p>
<p>v1 and v6 time-encoded UUIDs are useful because they can be generated much more quickly than any other form of UUID, as there is no need to to call a cryptographic random number generator.</p>
<p>v3/v5 deternibistic UUID’s are necessary because many of the interesting things that you can do with UUID’s require stable, reproducable, namespaced identifiers.</p>
<p>v7’s combine time encoding, secure cryptogrsphy, lexical ordering, and index-friendliness to provide a premium UUID experience, but at some additional cost to produce.</p>
<h3><a href="#how-big" id="how-big"></a>How Big?</h3>
<p>The provided namespace represents an <em>inexhaustable</em> resource and as such can be used in a variety of ways not feasible using traditional techniques rooted in the notions imposed by finite resources.  When I say “inexhaustable” this of course is slight hyperbolie, but not by much.  The upper bound on the representation implemented by this library limits the number of unique identifiers to a mere…</p>
<p><em>three hundred forty undecillion two hundred eighty-two decillion three</em> <em>hundred sixty-six nonillion nine hundred twenty octillion nine hundred</em> <em>thirty-eight septillion four hundred sixty-three sextillion four hundred</em> <em>sixty-three quintillion three hundred seventy-four quadrillion six hundred</em> <em>seven trillion four hundred thirty-one billion seven hundred sixty-eight</em> <em>million two hundred eleven thousand four hundred and fifty-five.</em></p>
<p>If you think you might be starting to run low, let me know when you get down to your last few undecillion or so and I’ll see what I can do to help out.</p>
<h3><a href="#usage" id="usage"></a>Usage</h3>
<p>Using clj-uuid is really easy.  Docstrings are provided, but sometimes examples help, too.  The following cases demonstrate about 90% of the functionality that you are likely to ever need.</p>
<p>In order to refer to the symbols in this library, it is recommended to <em>require</em> it in a given namespace:</p>
<pre><code class="language-clojure">
(require '[clj-uuid :as uuid])
</code></pre>
<p>Or include in namespace declaration:</p>
<pre><code class="language-clojure">
(ns foo
  (:require [clj-uuid :as uuid])
  ...
  )

</code></pre>
<h4><a href="#literal-syntax" id="literal-syntax"></a>Literal Syntax</h4>
<p>UUID’s have a convenient literal syntax supported by the clojure reader.  The tag <code>#uuid</code> denotes that the following string literal will be read as a UUID.  UUID’s evaluate to themselves:</p>
<pre><code class="language-clojure">
user&gt; #uuid "e6ff478d-9492-48dd-886d-23ec4c6385ee"

;;  =&gt; #uuid "e6ff478d-9492-48dd-886d-23ec4c6385ee"
</code></pre>
<h4><a href="#the-null-identifier" id="the-null-identifier"></a>The NULL Identifier</h4>
<p>The special UUID, <code>#uuid "00000000-0000-0000-0000-000000000000"</code> is known as the <em>null UUID</em> or <em>version 0 UUID</em> and can be useful for representing special values such as <em>nil</em> or <em>null-context</em>. One may reference the null UUID declaratively or functionally, although it is best to pick one convention and remain consistant. When comparing UUID’s the NULL UUID is considered the MININUM VALUE.</p>
<h4><a href="#the-max-identifier" id="the-max-identifier"></a>The MAX Identifier</h4>
<p>The special UUID, <code>#uuid "ffffffff-ffff-ffff-ffff-ffffffffffff"</code> is known as the <em>max UUID</em> and is used similarly to the <em>null UUID</em>.  When comparing UUID’s the NULL UUID is considered the MAXIMUM VALUE.</p>
<pre><code class="language-clojure">
user&gt; (uuid/null)

;;  =&gt; #uuid "00000000-0000-0000-0000-000000000000"


user&gt; (uuid/max)

;;  =&gt; #uuid "ffffffff-ffff-ffff-ffff-ffffffffffff"


user&gt; uuid/+null+

;;  =&gt; #uuid "00000000-0000-0000-0000-000000000000"


user&gt; uuid/+max+

;;  =&gt; #uuid "ffffffff-ffff-ffff-ffff-ffffffffffff"

</code></pre>
<h4><a href="#v6v1-fast-time-encoded-identifiers" id="v6v1-fast-time-encoded-identifiers"></a>v6/v1: Fast, Time Encoded Identifiers</h4>
<p>You can make your own v1 and v6 UUID’s with the functions <code>#'uuid/v1</code> and <code>#'uuid/v6</code>.  Either of these types of UUID’s will be the fastest to produce and guaranteed to be unique and thread-safe regardless of clock precision or degree of concurrency, but each with slightly different characteristics:</p>
<p>A v6 UUID encodes both the time and a random node identifier that is reset each time the library is loaded.  They are fast, lexically (aphabetically) ordered, and index friendly.</p>
<p>A v1 UUID is similar, but may reveal both the identity of the computer that generated the UUID and the time at which it did so.  Its uniqueness across computers is guaranteed as long as node/MAC addresses are not duplicated. In general, other than for legacy compatibility, the use case for this would be for situations where it is useful to know the provenance of any given UUID.  It does not provide lexical ordering or index-friendliness.</p>
<pre><code class="language-clojure">
(uuid/v6)

;; =&gt; #uuid "1ef7b36c-4ca7-6df0-91a1-233a797d04c0"
;; =&gt; #uuid "1ef7b36c-9c4c-60e0-91a1-233a797d04c0"
;; =&gt; #uuid "1ef7b373-1c84-6180-91a1-233a797d04c0"


(uuid/v1)

;; =&gt; #uuid "ffa803f0-b3d3-11e4-a03e-3af93c3de9ae"
;; =&gt; #uuid "005b7570-b3d4-11e4-a03e-3af93c3de9ae"
;; =&gt; #uuid "018a0a60-b3d4-11e4-a03e-3af93c3de9ae"
</code></pre>
<p>Either v6 or v1 identifiers are – <em>several times faster to generate than calling the JVM’s built-in static method for generating UUIDs</em>, <code>#'java.util.UUID/randomUUID</code>.</p>
<pre><code>user&gt; (criterium.core/bench (uuid/v6))

;; Execution time mean : 98.764073 ns

user&gt; (criterium/bench (java.util.UUID/randomUUID))

;; Execution time mean : 273.654110 ns

</code></pre>
<h5><a href="#sequential-temporal-namespace" id="sequential-temporal-namespace"></a>Sequential (Temporal) Namespace</h5>
<p>v6 and v1 UUID’s retrievably encode the time of their creation.  The native representation of this timestamp is as a 60 bit value indicating the number of 100 nanosecond intervals since the Gregorian epoch (for the younger readers, this was at 12am Friday October 15, 1582 UTC).</p>
<pre><code class="language-clojure">
user&gt; (uuid/get-timestamp (uuid/v6))

;;  =&gt; 136459064897650000


user&gt; (map uuid/get-timestamp (repeatedly 10 uuid/v1))

;;  =&gt; (136459065592300000
;;      136459065592310000
;;      136459065592320000
;;      136459065592340000
;;      136459065592340001 &lt;-+ subcounter ensures unique timestamp
;;      136459065592350000   | even when the resolution of the
;;      136459065592350001 &lt;-+ system clock is insufficiently
;;      136459065592370000   | granular to provide uniqueness.
;;      136459065592370001 &lt;-+
;;      136459065592380000)
</code></pre>
<p>Clearly, that is pretty useful.  We can look at any two time-based UUID’s and compare their timestamps relative to one another.  We can also look at the absolute timestamp values of time-based UUID’s using the ideomatic Clojure representation of timestamp values:</p>
<pre><code class="language-clojure">
user&gt; (uuid/get-instant (uuid/v1))

;;  =&gt; #inst "2015-03-17T17:51:15.970-00:00"


user&gt; (map uuid/get-instant (repeatedly 10 uuid/v1))

;;  =&gt; (#inst "2015-03-17T17:51:53.800-00:00" &lt;-+ Note, however,
;;      #inst "2015-03-17T17:51:53.800-00:00" &lt;-+ insufficient clock precision
;;      #inst "2015-03-17T17:51:53.802-00:00"   | to distinguish betweem
;;      #inst "2015-03-17T17:51:53.803-00:00" &lt;-+ absolute timestamp values
;;      #inst "2015-03-17T17:51:53.803-00:00" &lt;-+
;;      #inst "2015-03-17T17:51:53.804-00:00"
;;      #inst "2015-03-17T17:51:53.807-00:00"
;;      #inst "2015-03-17T17:51:53.808-00:00"
;;      #inst "2015-03-17T17:51:53.812-00:00"
;;      #inst "2015-03-17T17:51:53.814-00:00")
</code></pre>
<h4><a href="#v4-random-identifiers" id="v4-random-identifiers"></a>v4: Random Identifiers</h4>
<p>V4 identifiers are generated by directly invoking the static method <code>#'java.util.UUID/randomUUID</code> and are, in typical situations, slower to generate in addition to being non-deterministically unique. It exists primarily because it is very simple to implement and because randomly generated UUID’s are hard to guess.  They can be useful in that case, for example to seed a UUID namespace as we will see in a later example.</p>
<pre><code class="language-clojure">
user&gt; (uuid/v4)

;; =&gt; #uuid "49c248c3-d232-4960-b2f4-fd5a3a72ea62"
</code></pre>
<h4><a href="#v7-time-encoded-cryptographically-random-identifiers" id="v7-time-encoded-cryptographically-random-identifiers"></a>v7: Time Encoded Cryptographically Random Identifiers</h4>
<p>Combining the best features of all of the above, v7 UUIDs provide time encoding, lexical ordering, and entropy-friendly randomness, at, of course, some additional cost to compute.</p>
<pre><code class="language-clojure">
user&gt; (uuid/v7)

;; =&gt; #uuid "0192292b-c52c-7058-bdf8-741af201c7d3"

user&gt; (uuid/get-timestamp (uuid/v7))

;; =&gt; 1727267644205  (note -- POSIX time!)

user&gt; (uuid/get-instant (uuid/v7))

;; =&gt; #inst "2024-09-25T12:34:57.981-00:00"


user&gt; (criterium.core/bench (uuid/v7))

;; Execution time mean : 507.298388 ns

</code></pre>
<h4><a href="#lexical-comparability" id="lexical-comparability"></a>Lexical Comparability</h4>
<p>Ok, you’ve heard me mention “lexical odering” a few times. What does this mean?  v6 and v7 UUIDs offer identifiers that can be efficiently ordered alphabetically, requiring no decoding, based on order of their creation. Let’s take an example:</p>
<pre><code class="language-clojure">
user&gt; (def x (uuid/v7))

;; =&gt; #uuid "0192293c-8640-7058-9106-b97bf1754d98"

user&gt; (def y (uuid/v7))

;; =&gt; #uuid "0192293c-a931-709d-afba-5ad27082a4b6"

user&gt; (get-instant x)

;; =&gt; #inst "2024-09-25T12:51:25.376-00:00"

user&gt; (get-instant y)

;; =&gt; #inst "2024-09-25T12:51:34.321-00:00"

</code></pre>
<p>As you can see, it is always possible to order time encoded ids by parsing them, but v6 and v7 UUIDs make this easier, on any platform, even if you don’t have your trusty clj-uuid library available.</p>
<pre><code class="language-clojure">user&gt; (uuid/= x y)

;; =&gt; false

user&gt; (uuid/&lt; x y)

;; =&gt; true

user&gt; (clojure.core/compare (str x) (str y))

;; =&gt; -41  (negative -- ie, "less than")

user&gt; (clojure.core/compare (str y) (str x))

;; =&gt;  41  (positive -- ie  "greater than")


</code></pre>
<h4><a href="#v3v5-namespaced-identifiers" id="v3v5-namespaced-identifiers"></a>v3/v5: Namespaced Identifiers</h4>
<p>First of all, the only difference between v3 and v5 UUID’s is that v3’s are computed using an MD5 digest algorithm and v5’s are computed using SHA1. It is generally considered that SHA1 is a superior hash, but MD5 is computationally less expensive and so v3 may be preferred in situations requiring slightly faster performance. As such, when we give examples of namespaced identifiers, we will typically just use <code>v5</code> with the understanding that <code>v3</code> could be used identically in each case.</p>
<h5><a href="#namespaces" id="namespaces"></a>Namespaces</h5>
<p>If you are familiar with Clojure <em>vars</em>, you already understand the idea of <em>namespaced</em> identifiers.  To resolve the value of a var, one needs to know not only the <em>name</em> of a var, but also the <em>namespace</em> it resides in.  It is intuitively clear that vars <code>#'user/x</code> and <code>#'library/x</code> are distinct.  Namespaced UUID’s follow a similar concept, however namespaces are themselves represented as UUID’s. Names are strings that encode a representation of a symbol or value in the namespace of that identifier.  Given a namespace and a local-name, one can always (re)construct the unique identifier that represents it.  We can demonstrate a few examples constructed using several of the canonical top level namespace UUIDs:</p>
<pre><code class="language-clojure">
user&gt; (uuid/v5 uuid/+namespace-url+ "http://example.com/")

;;  =&gt; #uuid "0a300ee9-f9e4-5697-a51a-efc7fafaba67"

user&gt; (uuid/v5 uuid/+namespace-x500+ "http://example.com/")

;;  =&gt; #uuid "0cb29677-4eaf-578f-ab9b-f9ac67c33cb9"


user&gt; (uuid/v3 uuid/+namespace-dns+ "www.clojure.org")

;;  =&gt; #uuid "3bdca4f7-fc85-3a8b-9038-7626457527b0"


user&gt; (uuid/v5 uuid/+namespace-oid+ "0.1.22.13.8.236.1")

;;  =&gt; #uuid "9989a7d2-b7fc-5b6a-84d6-556b0531a065"
</code></pre>
<p>You can see in each case that the local “name” string is given in some well-definted format specific to each namespace.  This is a very common convention, but not enforced.  It is perfectly valid to construct a namespaced UUID from any literal string.</p>
<pre><code class="language-clojure">
user&gt; (uuid/v5 uuid/+namespace-url+ "I am clearly not a URL")

;;  =&gt; #uuid "a167a791-e550-57ae-b20f-666ee47ce7c1"
</code></pre>
<p>As a matter of fact, the requirements for a valid the local-part constituent are even more general than even just Strings.  Any kind of object will do:</p>
<pre><code class="language-clojure">
user&gt; (uuid/v5 uuid/+namespace-url+ :keyword)

;;  =&gt; #uuid "bc480d53-fba7-5e5f-8f33-6ad77880a007"

user&gt; (uuid/v5 uuid/+namespace-url+ :keyword)

;;  =&gt; #uuid "bc480d53-fba7-5e5f-8f33-6ad77880a007"

user&gt; (uuid/v5 uuid/+namespace-oid+ :keyword)

;;  =&gt; #uuid "9b3d8a3d-fadf-55b5-811f-12a0c50c3e86"



user&gt; (uuid/v5 uuid/+null+ 'this-symbol)

;;  =&gt; #uuid "8b2941d5-e40b-5364-afcf-0008833715a2"

user&gt; (uuid/v5 uuid/+null+ 'this-symbol)

;;  =&gt; #uuid "8b2941d5-e40b-5364-afcf-0008833715a2"


</code></pre>
<p>This will be most efficient for classes of object that have been extended with the <code>UUIDNameBytes</code> protocol.  If one intends to do such a thing fequently, it is a simple matter to specialize an <code>as-byte-array</code> method which can extract a byte serialization that represents the ‘name’ of an object, typically unique within some given namespace.  Here is a simple example where one adds specialized support for URLs to be quickly digested as the bytes of their string representation.</p>
<pre><code class="language-clojure">
(extend-protocol UUIDNameBytes java.net.URL
  (as-byte-array [this]
    (.getBytes (.toString this) StandardCharsets/UTF_8)))


(uuid/v5 uuid/+namespace-url+ "http://example.com/")

;; =&gt; #uuid "0a300ee9-f9e4-5697-a51a-efc7fafaba67"


(uuid/v5 uuid/+namespace-url+ (java.net.URL. "http://example.com/"))

;; =&gt; #uuid "0a300ee9-f9e4-5697-a51a-efc7fafaba67"

</code></pre>
<h5><a href="#hierarchical-namespace" id="hierarchical-namespace"></a>Hierarchical Namespace</h5>
<p>Because each UUID denotes its own namespace, it is easy to compose v5 identifiers in order to represent hierarchical sub-namespaces.  This, for example, can be used to assign unique identifiers based not only on the content of a string but the unique identity representing its source or provenance:</p>
<pre><code class="language-clojure">
user&gt; (uuid/v5
        (uuid/v5 uuid/+namespace-url+ "http://example.com/")
        "resource1#")

;;  =&gt; #uuid "6a3944a4-f00e-5921-b8b6-2cea5a745132"


user&gt; (uuid/v5
        (uuid/v5 uuid/+namespace-url+ "http://example.com/")
        "resource2#")

;;  =&gt; #uuid "98879e2a-8511-59ab-877d-ac6f8667866d"


user&gt; (uuid/v5
        (uuid/v5 uuid/+namespace-url+ "http://other.com/")
        "resource1#")

;;  =&gt; #uuid "bc956d0c-7af3-5b81-89f2-a96e8f9fd1a8"


user&gt; (uuid/v5
        (uuid/v5 uuid/+namespace-url+ "http://other.com/")
        "resource2#")

;;  =&gt; #uuid "a38b24fe-7ab8-58c8-a3f8-d3adb308260b"


</code></pre>
<p>Because UUID’s and namespaces can be chained together like this, one can be certain that the UUID resulting from a chain of calls such as the following will be unique – if and only if the original namespace matches:</p>
<pre><code class="language-clojure">
user&gt; (-&gt; (uuid/v1)
        (uuid/v5 "one")
        (uuid/v5 "two")
        (uuid/v5 "three"))

;;  =&gt; #uuid "eb7a0c2b-eb0e-5bb2-9819-3c9edc2814fa"


user&gt; (-&gt; (uuid/v1)
        (uuid/v5 "one")
        (uuid/v5 "two")
        (uuid/v5 "three"))

;;  =&gt; #uuid "45e8c272-1660-57ba-8892-6844e1d3196a"

</code></pre>
<p>At each step, the local part string must be identical, in order for the the final UUID to match:</p>
<pre><code class="language-clojure">
user&gt; (-&gt; uuid/+namespace-dns+
        (uuid/v5 "one")
        (uuid/v5 "two")
        (uuid/v5 "three"))

;;  =&gt; #uuid "617756cc-3b02-5a86-ad4a-ab3e1403dbd6"


user&gt; (-&gt; uuid/+namespace-dns+
        (uuid/v5 "two")
        (uuid/v5 "one")
        (uuid/v5 "three"))

;;  =&gt; #uuid "52d5453e-2aa1-53c1-b093-0ea20ef57ad1"

</code></pre>
<p>This capability can be used to represent uniqueness of a sequence of computations in, for example, a transaction system such as the one used in the graph-object database system <a href="http://github.com/lisp/de.setf.resource/">de.setf.resource</a> or this interesting new <a href="http://yuppiechef.github.io/cqrs-server/">CQRS/ES Server</a>.</p>
<h3><a href="#a-simple-example" id="a-simple-example"></a>A Simple Example</h3>
<p>Ok, so now you know how to use this nifty new UUID library and you are burning up to do something awesome with UUID’s… But, ah, hmmm… First you need to figure out what exactly you want to do with them.  Well, before you start working on your distributed cloud-based secret weapon, here is a simple way you can generate cryptographically secure activation keys for your draconian licensing scheme.</p>
<p>First, we pick a secret key.  We might pick a time-based id, or we might begin with some secret namespace, secret identifier pair to compute that initial namespace deterministically.  This is convenient, but not necessary – the time-based or random private key could also be stored in some form of persistent memory.  As unguessability important to deter hackers, we will choose a random namespace and record it in some secret, persistent storage to ensure we can regenerate a user’s activation code identically on-demand in the future.</p>
<pre><code class="language-clojure">
user&gt; (def +secret-weapon-licensing-namespace+ (uuid/v4))


user&gt; (uuid/v5 +secret-weapon-licensing-namespace+ "joe@example.com")

;;  =&gt; #uuid "b6433d1e-d369-5282-8dbc-bdd3845c376c"


user&gt; (uuid/v5 +secret-weapon-licensing-namespace+ "mom@knitting-arts.edu")

;;  =&gt; #uuid "81e4708c-85bb-5f3c-be56-bba4d8b0ac91"

</code></pre>
<p>Now, as the orders start rolling in for your product, you can crank out secret weapon activation codes just as well as if you were Microsoft. Each one will be keyed to a user’s email address and is guaranteed to be irreversible.  You will infuriate them with unreasonably high maintence support contract fees and intractible licensing terms. You truly are diabolical.</p>
<h3><a href="#basic-api" id="basic-api"></a>Basic API</h3>
<hr />
<h4><a href="#namespaces" id="namespaces"></a>Namespaces</h4>
<p><em>(var)</em>         <code>+null+</code></p>
<blockquote>
<p><code>#uuid "00000000-0000-0000-0000-000000000000"</code></p>
</blockquote>
<p><em>(var)</em>         <code>+max+</code></p>
<blockquote>
<p><code>#uuid "ffffffff-ffff-ffff-ffff-ffffffffffff"</code></p>
</blockquote>
<p><em>(var)</em>         <code>+namespace-dns+</code></p>
<blockquote>
<p><code>#uuid "6ba7b810-9dad-11d1-80b4-00c04fd430c8"</code></p>
</blockquote>
<p><em>(var)</em>         <code>+namespace-url+</code></p>
<blockquote>
<p><code>#uuid "6ba7b811-9dad-11d1-80b4-00c04fd430c8"</code></p>
</blockquote>
<p><em>(var)</em>         <code>+namespace-oid+</code></p>
<blockquote>
<p><code>#uuid "6ba7b812-9dad-11d1-80b4-00c04fd430c8"</code></p>
</blockquote>
<p><em>(var)</em>         <code>+namespace-x500+</code></p>
<blockquote>
<p><code>#uuid "6ba7b814-9dad-11d1-80b4-00c04fd430c8"</code></p>
</blockquote>
<hr />
<h4><a href="#generators" id="generators"></a>Generators</h4>
<p><em>(function)</em>    <code>null []</code></p>
<blockquote>
<p>Return the null UUID, a special form of sentinel UUID that is specified to have all 128 bits set to zero: #uuid “00000000-0000-0000-0000-000000000000”</p>
</blockquote>
<p><em>(function)</em>    <code>max []</code></p>
<blockquote>
<p>Return the max UUID, a special form of sentinel UUID that is specified to have all 128 bits set to one: "#uuid “ffffffff-ffff-ffff-ffff-ffffffffffff”</p>
</blockquote>
<p><em>(function)</em>    <code>v1 []</code></p>
<blockquote>
<p>Generate a v1 (time-based) unique identifier, guaranteed to be unique and thread-safe regardless of clock precision or degree of concurrency. Creation of v1 UUID’s does not require any call to a cryptographic generator and can be accomplished much more efficiently than v3, v4, v5, v7, or squuid’s.  A v1 UUID reveals both the identity of the computer that generated the UUID and the time at which it did so.  Its uniqueness across computers is guaranteed as long as MAC addresses are not duplicated.</p>
</blockquote>
<p><em>(function)</em>    <code>v3 [^UUID namespace ^Object local-name]</code></p>
<blockquote>
<p>Generate a v3 (name based, MD5 hash) UUID. context’ must be UUIDable. v3 identifiers are intended for generating UUID’s from names that are drawn from, and unique within, some namespace.  The concept of name and namespace should be broadly construed, and not limited to textual names. The requiremens for a v3 UUID are as follows:</p>
<ul>
<li>
<p>v3 UUID’s generated at different times from the same name in the same namespace MUST be equal.</p>
</li>
<li>
<p>v3 UUID’s generated from two different names in the same namespace SHOULD be distinct with a high degree of certainty.</p>
</li>
<li>
<p>v3 UUID’s generated from the same name in two different namespaces SHOULD be distinct with a high degree of certainty.</p>
</li>
<li>
<p>If two v3 UUID’s are equal, then there is a high degree of certainty that they were generated from the same name in the same namespace.</p>
</li>
</ul>
</blockquote>
<p><em>(function)</em>    <code>v4 []</code></p>
<p><em>(function)</em>    <code>v4 [^long msb, ^long lsb]</code></p>
<blockquote>
<p>Generate a v4 (random) UUID.  Uses default JVM implementation.  If two arguments, lsb and msb (both long) are provided, then construct a valid, properly formatted v4 UUID based on those values.  So, for example the following UUID, created from all zero bits, is indeed distinct from the null UUID:</p>
<pre><code> (v4)
  =&gt; #uuid "dcf0035f-ea29-4d1c-b52e-4ea499c6323e"

 (v4 0 0)
  =&gt; #uuid "00000000-0000-4000-8000-000000000000"

 (null)
  =&gt; #uuid "00000000-0000-0000-0000-000000000000"
</code></pre>
</blockquote>
<p><em>(function)</em>    <code>v5 [^UUID namespace ^Object local-name]</code></p>
<blockquote>
<p>Generate a v5 (name based, SHA1 hash) UUID. ‘context’ must be UUIDable. v5 identifiers are intended for generating UUID’s from names that are drawn from, and unique within, some namespace.  The concept of name and namespace should be broadly construed, and not limited to textual names. The requiremens for a v5 UUID are as follows:</p>
<ul>
<li>
<p>v5 UUID’s generated at different times from the same name in the same namespace MUST be equal.</p>
</li>
<li>
<p>v5 UUID’s generated from two different names in the same namespace SHOULD be distinct with a high degree of certainty.</p>
</li>
<li>
<p>v5 UUID’s generated from the same name in two different namespaces SHOULD be distinct with a high degree of certainty.</p>
</li>
<li>
<p>If two v5 UUID’s are equal, then there is a high degree of certainty that they were generated from the same name in the same namespace.</p>
</li>
</ul>
</blockquote>
<p><em>(function)</em>    <code>v6 []</code></p>
<blockquote>
<p>Generate a v6 (time-based), LEXICALLY SORTABLE, unique identifier, v6 is a field-compatible version of v1, reordered for improved DB locality.  Creation of v6 UUID’s does not require any call to a cryptographic generator and can be accomplished much more efficiently than v3, v4, v5, v7, or squuid’s.  A v6 UUID uses a cryptographically secure, hard to guess random node id. It DOES NOT reveal the identity of the computer on which it was created.</p>
</blockquote>
<p><em>(function)</em>    <code>v7 []</code></p>
<blockquote>
<p>Generate a v7 unix time-based, LEXICALLY SORTABLE UUID with monotonic counter, cryptographically secure random portion, and POSIX time encoding. As such, creation of v7 UUIDs may be slower, but have improved entropy chararacteristics compared to v1 or v6 UUIDs.</p>
</blockquote>
<p><em>(function)</em>    <code>v8 [^long msb, ^long lsb]</code></p>
<blockquote>
<p>Generate a v8 custom UUID with up to 122 bits of user data.</p>
</blockquote>
<p><em>(function)</em>    <code>squuid []</code></p>
<blockquote>
<p>Generate a SQUUID (sequential, random) unique identifier.  SQUUID’s are a nonstandard variation on v4 (random) UUIDs that have the desirable property that they increase sequentially over time as well as encode retrievably the posix time at which they were generated. Splits and reassembles a v4 UUID to merge current POSIX time (seconds since 12:00am January 1, 1970 UTC) with the most significant 32 bits of the UUID</p>
</blockquote>
<p><em>(function)</em>    <code>= [x]</code></p>
<p><em>(function)</em>    <code>= [x y]</code></p>
<p><em>(function)</em>    <code>= [x y &amp; more]</code></p>
<blockquote>
<p>Directly compare two or more UUIDs for = relation based on the ordinality semantics defined by <a href="RFC4122:3 RULES FOR LEXICAL
EQUIVALENCE">RFC4122:3 RULES FOR LEXICAL EQUIVALENCE</a>.</p>
</blockquote>
<p><em>(function)</em>    <code>&gt; [x]</code></p>
<p><em>(function)</em>    <code>&gt; [x y]</code></p>
<p><em>(function)</em>    <code>&gt; [x y &amp; more]</code></p>
<blockquote>
<p>Directly compare two or more UUIDs for &gt; relation based on the ordinality semantics defined by <a href="RFC4122:3 RULES FOR LEXICAL
EQUIVALENCE">RFC4122:3 RULES FOR LEXICAL EQUIVALENCE</a>.</p>
</blockquote>
<p><em>(function)</em>    <code>&lt; [x]</code></p>
<p><em>(function)</em>    <code>&lt; [x y]</code></p>
<p><em>(function)</em>    <code>&lt; [x y &amp; more]</code></p>
<blockquote>
<p>Directly compare two or more UUIDs for &lt; relation based on the ordinality semantics defined by <a href="RFC4122:3 RULES FOR LEXICAL
EQUIVALENCE">RFC4122:3 RULES FOR LEXICAL EQUIVALENCE</a>.</p>
</blockquote>
<p><em>(function)</em>    <code>monotonic-time []</code></p>
<blockquote>
<p>Return a monotonic timestamp (guaranteed always increasing)  based on the number of 100-nanosecond intervals elapsed since the adoption of the Gregorian calendar in the West, 12:00am Friday October 15, 1582 UTC.</p>
</blockquote>
<hr />
<h4><a href="#protocols" id="protocols"></a>Protocols</h4>
<p><em>(protocol)</em>    <code>UUIDNameBytes</code></p>
<blockquote>
<p>A mechanism intended for user-level extension that defines the decoding rules for the local-part representation of arbitrary Clojure / Java Objects when used for computing namespaced identifiers.</p>
<p><em>(member)</em>    <code>as-byte-array [self]</code></p>
<blockquote>
<p>Extract a byte serialization that represents the ‘name’ of x, typically unique within a given namespace.</p>
</blockquote>
</blockquote>
<p><em>(protocol)</em>    <code>UUIDable</code></p>
<blockquote>
<p>A UUIDable object directly represents a UUID.  Examples of things which might be conceptually ‘uuidable’ include string representation of a UUID in canonical hex format, or an appropriate URN URI.</p>
<p><em>(member)</em>    <code>as-uuid [self]</code></p>
<blockquote>
<p>Coerce the value of <code>self</code> to a java.util.UUID.</p>
</blockquote>
<p><em>(member)</em>    <code>uuidable? [self]</code></p>
<blockquote>
<p>Return ‘true’ if <code>self</code> can be coerced to UUID.</p>
</blockquote>
</blockquote>
<p><em>(protocol)</em>    <code>UUIDRfc4122</code></p>
<blockquote>
<p>Aliases UUIDRfc9526</p>
</blockquote>
<p><em>(protocol)</em>    <code>UUIDRfc9526</code></p>
<blockquote>
<p>A protocol that abstracts an unique identifier as described by IETF RFC9526 <a href="http://www.ietf.org/rfc/rfc9526.txt">http://www.ietf.org/rfc/rfc9526.txt</a>. A UUID represents a 128-bit value, however there are variant encoding layouts used to assign and interpret information encoded in those bits.  This is a protocol for  <em>variant 2</em> (<em>Leach-Salz</em>) UUID’s.</p>
<p><em>(member)</em>    <code>null? [self]</code></p>
<blockquote>
<p>Return <code>true</code> only if <code>self</code> has all 128 bits set ot zero and is therefore equal to the null UUID, <code>00000000-0000-0000-0000-000000000000</code>.</p>
</blockquote>
<p><em>(member)</em>    <code>uuid? [self]</code></p>
<blockquote>
<p>Return <code>true</code> if the class of <code>self</code> implements an RFC9526 unique identifier.</p>
</blockquote>
<p><em>(member)</em>    <code>uuid= [self other]</code></p>
<blockquote>
<p>Directly compare two UUID’s for <code>=</code> relation based on the equality semantics defined by <a href="RFC4122:3 &quot;RULES FOR LEXICAL EQUIVALENCE&quot;">RFC4122:3 “RULES FOR LEXICAL EQUIVALENCE”</a>.</p>
</blockquote>
<p><em>(member)</em>    <code>uuid&lt; [self other]</code></p>
<blockquote>
<p>Directly compare two UUID’s for <code>&lt;</code> relation based on the ordinality semantics defined by <a href="RFC4122:3 &quot;RULES FOR LEXICAL EQUIVALENCE&quot;">RFC4122:3 “RULES FOR LEXICAL EQUIVALENCE”</a>.</p>
</blockquote>
<p><em>(member)</em>    <code>uuid&gt; [self other]</code></p>
<blockquote>
<p>Directly compare two UUID’s for <code>&gt;</code> relation based on the ordinality semantics defined by <a href="RFC4122:3 &quot;RULES FOR LEXICAL EQUIVALENCE&quot;">RFC4122:3 “RULES FOR LEXICAL EQUIVALENCE”</a>.</p>
</blockquote>
<p><em>(member)</em>    <code>get-word-high [self]</code></p>
<blockquote>
<p>Return the most significant 64 bits of the 128 bit value of UUID <code>self</code>.</p>
</blockquote>
<p><em>(member)</em>    <code>get-word-low [self]</code></p>
<blockquote>
<p>Return the least significant 64 bits of the 128 bit value of UUID <code>self</code>.</p>
</blockquote>
<p><em>(member)</em>    <code>get-variant [self]</code></p>
<blockquote>
<p>Return the <em>variant</em> number associated with this UUID.  The variant field contains a value which identifies the layout of the UUID.  The bit-layout implemented by this protocol supports UUID’s with a variant value of 0x2, which indicates Leach-Salz layout.  Defined UUID variant values are:</p>
<pre><code>0x0   Null
0x2   Leach-Salz
0x6   Microsoft
0x7   Max
</code></pre>
<p>In the canonical representation, <code>xxxxxxxx-xxxx-xxxx-Nxxx-xxxxxxxxxxxx</code>, the most significant bits of N indicate the variant (depending on the variant one, two, or three bits are used). The variant covered by RFC4122 is indicated by the two most significant bits of <code>N</code> being <code>1 0</code> (i.e., the hexadecimal <code>N</code> will always be <code>8</code>, <code>9</code>, <code>A</code>, or <code>B</code>).</p>
</blockquote>
<p><em>(member)</em>    <code>get-version [self]</code></p>
<blockquote>
<p>Return the <em>version</em> number associated with this UUID.  The version field contains a value which describes the nature of the UUID.  There are five versions of Leach-Salz UUID, plus the null and max UUIDs:</p>
<pre><code>0x0   Null
0x1   Time based
0x2   DCE security with POSIX UID
0x3   Namespaced, deterministic (MD5 Digest)
0x4   Cryptographic random
0x5   Namespaced, deterministic (SHA1 Digest)
0x6   Time based, lexically ordered
0x7   POSIX Time based, lexically ordered, cryptographically secure
0x8   User Customizable
0xF   Max
</code></pre>
<p>In the canonical representation, xxxxxxxx-xxxx-Mxxx-xxxx-xxxxxxxxxxxx, the four bits of M indicate the UUID version (i.e., the hexadecimal M will be either 1, 2, 3, 4, 5, 6, 7, or 8).")</p>
</blockquote>
<p><em>(member)</em>    <code>get-timetamp [self]</code></p>
<blockquote>
<p>Return the time of UUID creation.  For Gregorian time-based (v1, v6) UUID’s, this is 60 bit unsigned value that represents a temporally unique timestamp associated with this UUID.  The result encodes the number of 100 nanosecond intervals since the adoption of the Gregorian calendar.  For v7 UUID’s this encodes the more common unix time in milliseconds since midnight, January 1, 1970 UTC.  For non-time-based (v3, v4, v5, v8, squuid) UUID’s, always returns <code>nil</code>.</p>
</blockquote>
<p><em>(member)</em>    <code>get-instant [self]</code></p>
<blockquote>
<p>For time-based (v1, v6, v7) UUID’s, return a <code>java.util.Date</code> object that represents the system time at which this UUID was generated. NOTE: the returned value may not necessarily be temporally unique. For non-time-based (v3, v4, v5, squuid) UUID’s, always returns <code>nil</code>.</p>
</blockquote>
<p><em>(member)</em>    <code>get-unix-time [self]</code></p>
<blockquote>
<p>For time-based (v1, v6, v7) UUIDs return the timestamp portion in aproximately milliseconds since the Unix epoch 1970-01-01T00:00:00.000Z. For non-time-based (v3, v4, v5, v8, squuid) UUID’s, always returns <code>nil</code>.</p>
</blockquote>
<p><em>(member)</em>    <code>get-time-low [self]</code></p>
<blockquote>
<p>Return the 32 bit unsigned value that represents the <em>time-low</em> field of the <em>timestamp</em> associated with this UUID.</p>
</blockquote>
<p><em>(member)</em>    <code>get-time-mid [self]</code></p>
<blockquote>
<p>Return the 16 bit unsigned value that represents the <em>time-mid</em> field of the <em>timestamp</em> assocaited with this UUID.</p>
</blockquote>
<p><em>(member)</em>    <code>get-time-high [self]</code></p>
<blockquote>
<p>Return the 16 bit unsigned value that represents the <em>time-high</em> field of the <em>timestamp</em> multiplexed with the <em>version</em> of this UUID.</p>
</blockquote>
<p><em>(member)</em>    <code>get-clk-seq [self]</code></p>
<blockquote>
<p>Return the <em>clk-seq</em> number associated with this UUID. For time-based (v1, v6) UUID’s the <em>clock-sequence</em> value is a somewhat counter-intuitively named seed-value that is used to reduce the potential that duplicate UUID’s might be generated under unusual situations, such as if the system hardware clock is set backward in time or if, despite all efforts otherwise, a duplicate <code>+node-id+</code> happens to be generated. This value is initialized to a random 16-bit number once per lifetime of the system.  For non-time-based (v3, v4, v5, squuid) UUID’s, always returns <code>nil</code>.</p>
</blockquote>
<p><em>(member)</em>    <code>get-clk-high [self]</code></p>
<blockquote>
<p>Return the 8 bit unsigned value that represents the most significant byte of the <em>clk-seq</em> multiplexed with the <em>variant</em> of this UUID.</p>
</blockquote>
<p><em>(member)</em>    <code>get-clk-low [self]</code></p>
<blockquote>
<p>Return the 8 bit unsigned value that represents the least significant byte of the <em>clk-seq</em> associated with this UUID.</p>
</blockquote>
<p><em>(member)</em>    <code>get-node-id [self]</code></p>
<blockquote>
<p>Return the 48 bit unsigned value that represents the spatially unique <em>node identifier</em> associated with this UUID.</p>
</blockquote>
<p><em>(member)</em>    <code>hash-code [self]</code></p>
<blockquote>
<p>Return a suitable 64-bit hash value for <code>self</code>.  Extend for specialized hash computation.</p>
</blockquote>
<p><em>(member)</em>    <code>to-byte-array [self]</code></p>
<blockquote>
<p>Return an array of 16 bytes that represents <code>self</code> as a decomposed octet serialization encoded in most-significant-byte first order.</p>
</blockquote>
<p><em>(member)</em>    <code>to-string [self]</code></p>
<blockquote>
<p>Return a String object that represents <code>self</code> in the canonical 36 character hexadecimal string format:</p>
<pre><code>"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
</code></pre>
</blockquote>
<p><em>(member)</em>    <code>to-hex-string [self]</code></p>
<blockquote>
<p>Return a String object that represents <code>self</code> as the 32 hexadecimal characters directly encodong the UUID’s 128 bit value:</p>
<pre><code>"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
</code></pre>
</blockquote>
<p><em>(member)</em>    <code>to-urn-string [self]</code></p>
<blockquote>
<p>Return a String object that represents <code>uuid</code> as a the string serialization of the URN URI based on the canonical 36 character hex-string representation:</p>
<pre><code>"urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
</code></pre>
</blockquote>
<p><em>(member)</em>    <code>to-uri [self]</code></p>
<blockquote>
<p>Return the unique URN URI associated with this UUID.</p>
</blockquote>
</blockquote>
<h3><a href="#references" id="references"></a>References</h3>
<ul>
<li>
<p><a href="http://www.ietf.org/rfc/rfc9562.txt">IETF RFC-9562</a> <em>Universally Unique IDentifiers (UUIDs)</em></p>
</li>
<li>
<p><a href="http://www.ietf.org/rfc/rfc4122.txt">IETF RFC-4122</a> <em>A Universally Unique IDentifier (UUID) URN Namespace</em></p>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/Universally_unique_identifier">Wikipedia/<em>Universally unique identifier</em></a></p>
</li>
<li>
<p><a href="http://www.dardoria.net/software/uuid.html">CL-UUID</a> reference implementation</p>
</li>
<li>
<p><a href="https://github.com/mon-key/unicly">UNICLY</a> reference implementation</p>
</li>
<li>
<p><a href="http://docs.oracle.com/javase/6/docs/api/java/util/UUID.html">java.util.UUID</a> JavaDoc</p>
</li>
<li>
<p><a href="http://www.darksleep.com/player/JavaAndUnsignedTypes.html">Java and Unsigned Primitive Datatypes</a></p>
</li>
<li>
<p><a href="http://joearms.github.io/2015/03/12/The_web_of_names.html">The web of names, hashes, and UUIDs</a></p>
</li>
<li>
<p><a href="http://blog.find-method.de/index.php?/archives/200-Coding-katas-Clojure-Bloom-filters.html">Coding Katas Clojure – Bloom Filters</a></p>
</li>
</ul>
<h3><a href="#special-thanks" id="special-thanks"></a>Special Thanks</h3>
<p><img src="https://www.yourkit.com/images/yklogo.png" alt="YourKit" /></p>
<p>YourKit supports open source projects with its full-featured Java Profiler. YourKit, LLC is the creator of <a href="https://www.yourkit.com/java/profiler/index.jsp">YourKit Java Profiler</a> and <a href="https://www.yourkit.com/.net/profiler/index.jsp">YourKit .NET Profiler</a>, innovative and intelligent tools for profiling Java and .NET applications.</p>
<h3><a href="#license" id="license"></a>License</h3>
<p>Copyright © 2024 Dan Lentz</p>
<p>Distributed under the Eclipse Public License version 1.0</p>
</div></div></div></body></html>